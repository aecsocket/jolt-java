// Generated by jextract

package jolt.headers;

import java.lang.foreign.*;
import java.lang.invoke.VarHandle;

import static java.lang.foreign.ValueLayout.PathElement;
public class JPC_MotionProperties {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        MemoryLayout.sequenceLayout(4, Constants$root.C_FLOAT$LAYOUT).withName("linear_velocity"),
        MemoryLayout.sequenceLayout(4, Constants$root.C_FLOAT$LAYOUT).withName("angular_velocity"),
        MemoryLayout.sequenceLayout(4, Constants$root.C_FLOAT$LAYOUT).withName("inv_inertia_diagnonal"),
        MemoryLayout.sequenceLayout(4, Constants$root.C_FLOAT$LAYOUT).withName("inertia_rotation"),
        MemoryLayout.sequenceLayout(3, Constants$root.C_FLOAT$LAYOUT).withName("force"),
        MemoryLayout.sequenceLayout(3, Constants$root.C_FLOAT$LAYOUT).withName("torque"),
        Constants$root.C_FLOAT$LAYOUT.withName("inv_mass"),
        Constants$root.C_FLOAT$LAYOUT.withName("linear_damping"),
        Constants$root.C_FLOAT$LAYOUT.withName("angular_daming"),
        Constants$root.C_FLOAT$LAYOUT.withName("max_linear_velocity"),
        Constants$root.C_FLOAT$LAYOUT.withName("max_angular_velocity"),
        Constants$root.C_FLOAT$LAYOUT.withName("gravity_factor"),
        Constants$root.C_INT$LAYOUT.withName("index_in_active_bodies"),
        Constants$root.C_INT$LAYOUT.withName("island_index"),
        Constants$root.C_CHAR$LAYOUT.withName("motion_quality"),
        Constants$root.C_BOOL$LAYOUT.withName("allow_sleeping"),
        MemoryLayout.paddingLayout(16),
        MemoryLayout.sequenceLayout(52, Constants$root.C_CHAR$LAYOUT).withName("reserved")
    ).withName("JPC_MotionProperties");
    public static MemoryLayout $LAYOUT() {
        return JPC_MotionProperties.$struct$LAYOUT;
    }
    public static MemorySegment linear_velocity$slice(MemorySegment seg) {
        return seg.asSlice(0, 16);
    }
    public static MemorySegment angular_velocity$slice(MemorySegment seg) {
        return seg.asSlice(16, 16);
    }
    public static MemorySegment inv_inertia_diagnonal$slice(MemorySegment seg) {
        return seg.asSlice(32, 16);
    }
    public static MemorySegment inertia_rotation$slice(MemorySegment seg) {
        return seg.asSlice(48, 16);
    }
    public static MemorySegment force$slice(MemorySegment seg) {
        return seg.asSlice(64, 12);
    }
    public static MemorySegment torque$slice(MemorySegment seg) {
        return seg.asSlice(76, 12);
    }
    static final VarHandle inv_mass$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("inv_mass"));
    public static VarHandle inv_mass$VH() {
        return JPC_MotionProperties.inv_mass$VH;
    }
    public static float inv_mass$get(MemorySegment seg) {
        return (float)JPC_MotionProperties.inv_mass$VH.get(seg);
    }
    public static void inv_mass$set( MemorySegment seg, float x) {
        JPC_MotionProperties.inv_mass$VH.set(seg, x);
    }
    public static float inv_mass$get(MemorySegment seg, long index) {
        return (float)JPC_MotionProperties.inv_mass$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void inv_mass$set(MemorySegment seg, long index, float x) {
        JPC_MotionProperties.inv_mass$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle linear_damping$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("linear_damping"));
    public static VarHandle linear_damping$VH() {
        return JPC_MotionProperties.linear_damping$VH;
    }
    public static float linear_damping$get(MemorySegment seg) {
        return (float)JPC_MotionProperties.linear_damping$VH.get(seg);
    }
    public static void linear_damping$set( MemorySegment seg, float x) {
        JPC_MotionProperties.linear_damping$VH.set(seg, x);
    }
    public static float linear_damping$get(MemorySegment seg, long index) {
        return (float)JPC_MotionProperties.linear_damping$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void linear_damping$set(MemorySegment seg, long index, float x) {
        JPC_MotionProperties.linear_damping$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle angular_daming$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("angular_daming"));
    public static VarHandle angular_daming$VH() {
        return JPC_MotionProperties.angular_daming$VH;
    }
    public static float angular_daming$get(MemorySegment seg) {
        return (float)JPC_MotionProperties.angular_daming$VH.get(seg);
    }
    public static void angular_daming$set( MemorySegment seg, float x) {
        JPC_MotionProperties.angular_daming$VH.set(seg, x);
    }
    public static float angular_daming$get(MemorySegment seg, long index) {
        return (float)JPC_MotionProperties.angular_daming$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void angular_daming$set(MemorySegment seg, long index, float x) {
        JPC_MotionProperties.angular_daming$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle max_linear_velocity$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("max_linear_velocity"));
    public static VarHandle max_linear_velocity$VH() {
        return JPC_MotionProperties.max_linear_velocity$VH;
    }
    public static float max_linear_velocity$get(MemorySegment seg) {
        return (float)JPC_MotionProperties.max_linear_velocity$VH.get(seg);
    }
    public static void max_linear_velocity$set( MemorySegment seg, float x) {
        JPC_MotionProperties.max_linear_velocity$VH.set(seg, x);
    }
    public static float max_linear_velocity$get(MemorySegment seg, long index) {
        return (float)JPC_MotionProperties.max_linear_velocity$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void max_linear_velocity$set(MemorySegment seg, long index, float x) {
        JPC_MotionProperties.max_linear_velocity$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle max_angular_velocity$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("max_angular_velocity"));
    public static VarHandle max_angular_velocity$VH() {
        return JPC_MotionProperties.max_angular_velocity$VH;
    }
    public static float max_angular_velocity$get(MemorySegment seg) {
        return (float)JPC_MotionProperties.max_angular_velocity$VH.get(seg);
    }
    public static void max_angular_velocity$set( MemorySegment seg, float x) {
        JPC_MotionProperties.max_angular_velocity$VH.set(seg, x);
    }
    public static float max_angular_velocity$get(MemorySegment seg, long index) {
        return (float)JPC_MotionProperties.max_angular_velocity$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void max_angular_velocity$set(MemorySegment seg, long index, float x) {
        JPC_MotionProperties.max_angular_velocity$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle gravity_factor$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("gravity_factor"));
    public static VarHandle gravity_factor$VH() {
        return JPC_MotionProperties.gravity_factor$VH;
    }
    public static float gravity_factor$get(MemorySegment seg) {
        return (float)JPC_MotionProperties.gravity_factor$VH.get(seg);
    }
    public static void gravity_factor$set( MemorySegment seg, float x) {
        JPC_MotionProperties.gravity_factor$VH.set(seg, x);
    }
    public static float gravity_factor$get(MemorySegment seg, long index) {
        return (float)JPC_MotionProperties.gravity_factor$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void gravity_factor$set(MemorySegment seg, long index, float x) {
        JPC_MotionProperties.gravity_factor$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle index_in_active_bodies$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("index_in_active_bodies"));
    public static VarHandle index_in_active_bodies$VH() {
        return JPC_MotionProperties.index_in_active_bodies$VH;
    }
    public static int index_in_active_bodies$get(MemorySegment seg) {
        return (int)JPC_MotionProperties.index_in_active_bodies$VH.get(seg);
    }
    public static void index_in_active_bodies$set( MemorySegment seg, int x) {
        JPC_MotionProperties.index_in_active_bodies$VH.set(seg, x);
    }
    public static int index_in_active_bodies$get(MemorySegment seg, long index) {
        return (int)JPC_MotionProperties.index_in_active_bodies$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void index_in_active_bodies$set(MemorySegment seg, long index, int x) {
        JPC_MotionProperties.index_in_active_bodies$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle island_index$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("island_index"));
    public static VarHandle island_index$VH() {
        return JPC_MotionProperties.island_index$VH;
    }
    public static int island_index$get(MemorySegment seg) {
        return (int)JPC_MotionProperties.island_index$VH.get(seg);
    }
    public static void island_index$set( MemorySegment seg, int x) {
        JPC_MotionProperties.island_index$VH.set(seg, x);
    }
    public static int island_index$get(MemorySegment seg, long index) {
        return (int)JPC_MotionProperties.island_index$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void island_index$set(MemorySegment seg, long index, int x) {
        JPC_MotionProperties.island_index$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle motion_quality$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("motion_quality"));
    public static VarHandle motion_quality$VH() {
        return JPC_MotionProperties.motion_quality$VH;
    }
    public static byte motion_quality$get(MemorySegment seg) {
        return (byte)JPC_MotionProperties.motion_quality$VH.get(seg);
    }
    public static void motion_quality$set( MemorySegment seg, byte x) {
        JPC_MotionProperties.motion_quality$VH.set(seg, x);
    }
    public static byte motion_quality$get(MemorySegment seg, long index) {
        return (byte)JPC_MotionProperties.motion_quality$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void motion_quality$set(MemorySegment seg, long index, byte x) {
        JPC_MotionProperties.motion_quality$VH.set(seg.asSlice(index*sizeof()), x);
    }
    static final VarHandle allow_sleeping$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("allow_sleeping"));
    public static VarHandle allow_sleeping$VH() {
        return JPC_MotionProperties.allow_sleeping$VH;
    }
    public static boolean allow_sleeping$get(MemorySegment seg) {
        return (boolean)JPC_MotionProperties.allow_sleeping$VH.get(seg);
    }
    public static void allow_sleeping$set( MemorySegment seg, boolean x) {
        JPC_MotionProperties.allow_sleeping$VH.set(seg, x);
    }
    public static boolean allow_sleeping$get(MemorySegment seg, long index) {
        return (boolean)JPC_MotionProperties.allow_sleeping$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void allow_sleeping$set(MemorySegment seg, long index, boolean x) {
        JPC_MotionProperties.allow_sleeping$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static MemorySegment reserved$slice(MemorySegment seg) {
        return seg.asSlice(124, 52);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, MemorySession session) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, session); }
}


